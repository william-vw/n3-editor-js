# Generated from n3.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,55,224,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,1,0,1,0,1,0,1,0,5,0,65,8,0,10,0,12,
        0,68,9,0,1,0,1,0,1,1,1,1,3,1,74,8,1,1,2,1,2,3,2,78,8,2,1,3,1,3,3,
        3,82,8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,7,1,7,1,7,
        1,8,1,8,3,8,100,8,8,1,9,1,9,1,9,1,9,1,9,1,9,3,9,108,8,9,5,9,110,
        8,9,10,9,12,9,113,9,9,1,10,1,10,1,10,5,10,118,8,10,10,10,12,10,121,
        9,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,
        134,8,11,1,12,1,12,1,13,1,13,1,13,3,13,141,8,13,1,14,1,14,1,15,1,
        15,1,16,1,16,1,16,1,16,1,16,3,16,152,8,16,1,17,1,17,1,17,1,17,1,
        17,1,17,1,17,1,17,3,17,162,8,17,1,18,1,18,1,18,3,18,167,8,18,1,19,
        1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,21,1,21,5,21,180,8,21,
        10,21,12,21,183,9,21,1,21,1,21,1,22,1,22,3,22,189,8,22,1,22,1,22,
        1,23,1,23,1,23,3,23,196,8,23,3,23,198,8,23,1,23,1,23,3,23,202,8,
        23,3,23,204,8,23,1,24,1,24,1,25,1,25,1,25,1,25,3,25,212,8,25,1,26,
        1,26,3,26,216,8,26,1,27,1,27,1,28,1,28,1,29,1,29,1,29,0,0,30,0,2,
        4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
        50,52,54,56,58,0,3,1,0,31,33,1,0,27,28,2,0,29,29,43,43,229,0,66,
        1,0,0,0,2,73,1,0,0,0,4,77,1,0,0,0,6,81,1,0,0,0,8,83,1,0,0,0,10,86,
        1,0,0,0,12,90,1,0,0,0,14,94,1,0,0,0,16,97,1,0,0,0,18,101,1,0,0,0,
        20,114,1,0,0,0,22,133,1,0,0,0,24,135,1,0,0,0,26,140,1,0,0,0,28,142,
        1,0,0,0,30,144,1,0,0,0,32,146,1,0,0,0,34,161,1,0,0,0,36,166,1,0,
        0,0,38,168,1,0,0,0,40,172,1,0,0,0,42,177,1,0,0,0,44,186,1,0,0,0,
        46,203,1,0,0,0,48,205,1,0,0,0,50,207,1,0,0,0,52,215,1,0,0,0,54,217,
        1,0,0,0,56,219,1,0,0,0,58,221,1,0,0,0,60,61,3,2,1,0,61,62,5,1,0,
        0,62,65,1,0,0,0,63,65,3,6,3,0,64,60,1,0,0,0,64,63,1,0,0,0,65,68,
        1,0,0,0,66,64,1,0,0,0,66,67,1,0,0,0,67,69,1,0,0,0,68,66,1,0,0,0,
        69,70,5,0,0,1,70,1,1,0,0,0,71,74,3,4,2,0,72,74,3,16,8,0,73,71,1,
        0,0,0,73,72,1,0,0,0,74,3,1,0,0,0,75,78,3,12,6,0,76,78,3,14,7,0,77,
        75,1,0,0,0,77,76,1,0,0,0,78,5,1,0,0,0,79,82,3,8,4,0,80,82,3,10,5,
        0,81,79,1,0,0,0,81,80,1,0,0,0,82,7,1,0,0,0,83,84,5,48,0,0,84,85,
        5,26,0,0,85,9,1,0,0,0,86,87,5,49,0,0,87,88,5,27,0,0,88,89,5,26,0,
        0,89,11,1,0,0,0,90,91,5,2,0,0,91,92,5,27,0,0,92,93,5,26,0,0,93,13,
        1,0,0,0,94,95,5,3,0,0,95,96,5,26,0,0,96,15,1,0,0,0,97,99,3,24,12,
        0,98,100,3,18,9,0,99,98,1,0,0,0,99,100,1,0,0,0,100,17,1,0,0,0,101,
        102,3,22,11,0,102,111,3,20,10,0,103,107,5,4,0,0,104,105,3,22,11,
        0,105,106,3,20,10,0,106,108,1,0,0,0,107,104,1,0,0,0,107,108,1,0,
        0,0,108,110,1,0,0,0,109,103,1,0,0,0,110,113,1,0,0,0,111,109,1,0,
        0,0,111,112,1,0,0,0,112,19,1,0,0,0,113,111,1,0,0,0,114,119,3,28,
        14,0,115,116,5,5,0,0,116,118,3,28,14,0,117,115,1,0,0,0,118,121,1,
        0,0,0,119,117,1,0,0,0,119,120,1,0,0,0,120,21,1,0,0,0,121,119,1,0,
        0,0,122,134,3,26,13,0,123,134,5,6,0,0,124,125,5,7,0,0,125,134,3,
        30,15,0,126,127,5,8,0,0,127,128,3,30,15,0,128,129,5,9,0,0,129,134,
        1,0,0,0,130,134,5,10,0,0,131,134,5,11,0,0,132,134,5,12,0,0,133,122,
        1,0,0,0,133,123,1,0,0,0,133,124,1,0,0,0,133,126,1,0,0,0,133,130,
        1,0,0,0,133,131,1,0,0,0,133,132,1,0,0,0,134,23,1,0,0,0,135,136,3,
        30,15,0,136,25,1,0,0,0,137,141,3,30,15,0,138,139,5,13,0,0,139,141,
        3,30,15,0,140,137,1,0,0,0,140,138,1,0,0,0,141,27,1,0,0,0,142,143,
        3,30,15,0,143,29,1,0,0,0,144,145,3,32,16,0,145,31,1,0,0,0,146,151,
        3,34,17,0,147,148,5,14,0,0,148,152,3,32,16,0,149,150,5,15,0,0,150,
        152,3,32,16,0,151,147,1,0,0,0,151,149,1,0,0,0,151,152,1,0,0,0,152,
        33,1,0,0,0,153,162,3,52,26,0,154,162,3,56,28,0,155,162,3,58,29,0,
        156,162,3,42,21,0,157,162,3,38,19,0,158,162,3,40,20,0,159,162,3,
        36,18,0,160,162,3,44,22,0,161,153,1,0,0,0,161,154,1,0,0,0,161,155,
        1,0,0,0,161,156,1,0,0,0,161,157,1,0,0,0,161,158,1,0,0,0,161,159,
        1,0,0,0,161,160,1,0,0,0,162,35,1,0,0,0,163,167,3,50,25,0,164,167,
        3,48,24,0,165,167,5,24,0,0,166,163,1,0,0,0,166,164,1,0,0,0,166,165,
        1,0,0,0,167,37,1,0,0,0,168,169,5,16,0,0,169,170,3,18,9,0,170,171,
        5,17,0,0,171,39,1,0,0,0,172,173,5,42,0,0,173,174,3,52,26,0,174,175,
        3,18,9,0,175,176,5,17,0,0,176,41,1,0,0,0,177,181,5,18,0,0,178,180,
        3,28,14,0,179,178,1,0,0,0,180,183,1,0,0,0,181,179,1,0,0,0,181,182,
        1,0,0,0,182,184,1,0,0,0,183,181,1,0,0,0,184,185,5,19,0,0,185,43,
        1,0,0,0,186,188,5,20,0,0,187,189,3,46,23,0,188,187,1,0,0,0,188,189,
        1,0,0,0,189,190,1,0,0,0,190,191,5,21,0,0,191,45,1,0,0,0,192,197,
        3,2,1,0,193,195,5,1,0,0,194,196,3,46,23,0,195,194,1,0,0,0,195,196,
        1,0,0,0,196,198,1,0,0,0,197,193,1,0,0,0,197,198,1,0,0,0,198,204,
        1,0,0,0,199,201,3,6,3,0,200,202,3,46,23,0,201,200,1,0,0,0,201,202,
        1,0,0,0,202,204,1,0,0,0,203,192,1,0,0,0,203,199,1,0,0,0,204,47,1,
        0,0,0,205,206,7,0,0,0,206,49,1,0,0,0,207,211,5,25,0,0,208,212,5,
        30,0,0,209,210,5,22,0,0,210,212,3,52,26,0,211,208,1,0,0,0,211,209,
        1,0,0,0,211,212,1,0,0,0,212,51,1,0,0,0,213,216,5,26,0,0,214,216,
        3,54,27,0,215,213,1,0,0,0,215,214,1,0,0,0,216,53,1,0,0,0,217,218,
        7,1,0,0,218,55,1,0,0,0,219,220,7,2,0,0,220,57,1,0,0,0,221,222,5,
        44,0,0,222,59,1,0,0,0,22,64,66,73,77,81,99,107,111,119,133,140,151,
        161,166,181,188,195,197,201,203,211,215
    ]

class n3Parser ( Parser ):

    grammarFileName = "n3.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "'@prefix'", "'@base'", "';'", 
                     "','", "'a'", "'has'", "'is'", "'of'", "'='", "'<='", 
                     "'=>'", "'<-'", "'!'", "'^'", "'['", "']'", "'('", 
                     "')'", "'{'", "'}'", "'^^'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "COMMENT", 
                      "BooleanLiteral", "String", "IRIREF", "PNAME_NS", 
                      "PNAME_LN", "BLANK_NODE_LABEL", "LANGTAG", "INTEGER", 
                      "DECIMAL", "DOUBLE", "EXPONENT", "STRING_LITERAL_LONG_SINGLE_QUOTE", 
                      "STRING_LITERAL_LONG_QUOTE", "STRING_LITERAL_QUOTE", 
                      "STRING_LITERAL_SINGLE_QUOTE", "UCHAR", "ECHAR", "WS", 
                      "IPLSTART", "ANON", "QuickVarName", "PN_CHARS_U", 
                      "PN_CHARS_BASE", "PN_CHARS", "BASE", "PREFIX", "PN_PREFIX", 
                      "PN_LOCAL", "PLX", "PERCENT", "HEX", "PN_LOCAL_ESC" ]

    RULE_n3Doc = 0
    RULE_n3Statement = 1
    RULE_n3Directive = 2
    RULE_sparqlDirective = 3
    RULE_sparqlBase = 4
    RULE_sparqlPrefix = 5
    RULE_prefixID = 6
    RULE_base = 7
    RULE_triples = 8
    RULE_predicateObjectList = 9
    RULE_objectList = 10
    RULE_verb = 11
    RULE_subject = 12
    RULE_predicate = 13
    RULE_object = 14
    RULE_expression = 15
    RULE_path = 16
    RULE_pathItem = 17
    RULE_literal = 18
    RULE_blankNodePropertyList = 19
    RULE_iriPropertyList = 20
    RULE_collection = 21
    RULE_formula = 22
    RULE_formulaContent = 23
    RULE_numericLiteral = 24
    RULE_rdfLiteral = 25
    RULE_iri = 26
    RULE_prefixedName = 27
    RULE_blankNode = 28
    RULE_quickVar = 29

    ruleNames =  [ "n3Doc", "n3Statement", "n3Directive", "sparqlDirective", 
                   "sparqlBase", "sparqlPrefix", "prefixID", "base", "triples", 
                   "predicateObjectList", "objectList", "verb", "subject", 
                   "predicate", "object", "expression", "path", "pathItem", 
                   "literal", "blankNodePropertyList", "iriPropertyList", 
                   "collection", "formula", "formulaContent", "numericLiteral", 
                   "rdfLiteral", "iri", "prefixedName", "blankNode", "quickVar" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    COMMENT=23
    BooleanLiteral=24
    String=25
    IRIREF=26
    PNAME_NS=27
    PNAME_LN=28
    BLANK_NODE_LABEL=29
    LANGTAG=30
    INTEGER=31
    DECIMAL=32
    DOUBLE=33
    EXPONENT=34
    STRING_LITERAL_LONG_SINGLE_QUOTE=35
    STRING_LITERAL_LONG_QUOTE=36
    STRING_LITERAL_QUOTE=37
    STRING_LITERAL_SINGLE_QUOTE=38
    UCHAR=39
    ECHAR=40
    WS=41
    IPLSTART=42
    ANON=43
    QuickVarName=44
    PN_CHARS_U=45
    PN_CHARS_BASE=46
    PN_CHARS=47
    BASE=48
    PREFIX=49
    PN_PREFIX=50
    PN_LOCAL=51
    PLX=52
    PERCENT=53
    HEX=54
    PN_LOCAL_ESC=55

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class N3DocContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(n3Parser.EOF, 0)

        def n3Statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.N3StatementContext)
            else:
                return self.getTypedRuleContext(n3Parser.N3StatementContext,i)


        def sparqlDirective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.SparqlDirectiveContext)
            else:
                return self.getTypedRuleContext(n3Parser.SparqlDirectiveContext,i)


        def getRuleIndex(self):
            return n3Parser.RULE_n3Doc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterN3Doc" ):
                listener.enterN3Doc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitN3Doc" ):
                listener.exitN3Doc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitN3Doc" ):
                return visitor.visitN3Doc(self)
            else:
                return visitor.visitChildren(self)




    def n3Doc(self):

        localctx = n3Parser.N3DocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_n3Doc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 875227346436108) != 0):
                self.state = 64
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [2, 3, 16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                    self.state = 60
                    self.n3Statement()
                    self.state = 61
                    self.match(n3Parser.T__0)
                    pass
                elif token in [48, 49]:
                    self.state = 63
                    self.sparqlDirective()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 68
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 69
            self.match(n3Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class N3StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def n3Directive(self):
            return self.getTypedRuleContext(n3Parser.N3DirectiveContext,0)


        def triples(self):
            return self.getTypedRuleContext(n3Parser.TriplesContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_n3Statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterN3Statement" ):
                listener.enterN3Statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitN3Statement" ):
                listener.exitN3Statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitN3Statement" ):
                return visitor.visitN3Statement(self)
            else:
                return visitor.visitChildren(self)




    def n3Statement(self):

        localctx = n3Parser.N3StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_n3Statement)
        try:
            self.state = 73
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2, 3]:
                self.enterOuterAlt(localctx, 1)
                self.state = 71
                self.n3Directive()
                pass
            elif token in [16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.triples()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class N3DirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixID(self):
            return self.getTypedRuleContext(n3Parser.PrefixIDContext,0)


        def base(self):
            return self.getTypedRuleContext(n3Parser.BaseContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_n3Directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterN3Directive" ):
                listener.enterN3Directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitN3Directive" ):
                listener.exitN3Directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitN3Directive" ):
                return visitor.visitN3Directive(self)
            else:
                return visitor.visitChildren(self)




    def n3Directive(self):

        localctx = n3Parser.N3DirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_n3Directive)
        try:
            self.state = 77
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 75
                self.prefixID()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 76
                self.base()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SparqlDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sparqlBase(self):
            return self.getTypedRuleContext(n3Parser.SparqlBaseContext,0)


        def sparqlPrefix(self):
            return self.getTypedRuleContext(n3Parser.SparqlPrefixContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_sparqlDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSparqlDirective" ):
                listener.enterSparqlDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSparqlDirective" ):
                listener.exitSparqlDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSparqlDirective" ):
                return visitor.visitSparqlDirective(self)
            else:
                return visitor.visitChildren(self)




    def sparqlDirective(self):

        localctx = n3Parser.SparqlDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_sparqlDirective)
        try:
            self.state = 81
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 79
                self.sparqlBase()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 2)
                self.state = 80
                self.sparqlPrefix()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SparqlBaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BASE(self):
            return self.getToken(n3Parser.BASE, 0)

        def IRIREF(self):
            return self.getToken(n3Parser.IRIREF, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_sparqlBase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSparqlBase" ):
                listener.enterSparqlBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSparqlBase" ):
                listener.exitSparqlBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSparqlBase" ):
                return visitor.visitSparqlBase(self)
            else:
                return visitor.visitChildren(self)




    def sparqlBase(self):

        localctx = n3Parser.SparqlBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_sparqlBase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(n3Parser.BASE)
            self.state = 84
            self.match(n3Parser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SparqlPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREFIX(self):
            return self.getToken(n3Parser.PREFIX, 0)

        def PNAME_NS(self):
            return self.getToken(n3Parser.PNAME_NS, 0)

        def IRIREF(self):
            return self.getToken(n3Parser.IRIREF, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_sparqlPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSparqlPrefix" ):
                listener.enterSparqlPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSparqlPrefix" ):
                listener.exitSparqlPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSparqlPrefix" ):
                return visitor.visitSparqlPrefix(self)
            else:
                return visitor.visitChildren(self)




    def sparqlPrefix(self):

        localctx = n3Parser.SparqlPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_sparqlPrefix)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(n3Parser.PREFIX)
            self.state = 87
            self.match(n3Parser.PNAME_NS)
            self.state = 88
            self.match(n3Parser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PNAME_NS(self):
            return self.getToken(n3Parser.PNAME_NS, 0)

        def IRIREF(self):
            return self.getToken(n3Parser.IRIREF, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_prefixID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixID" ):
                listener.enterPrefixID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixID" ):
                listener.exitPrefixID(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixID" ):
                return visitor.visitPrefixID(self)
            else:
                return visitor.visitChildren(self)




    def prefixID(self):

        localctx = n3Parser.PrefixIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_prefixID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.match(n3Parser.T__1)
            self.state = 91
            self.match(n3Parser.PNAME_NS)
            self.state = 92
            self.match(n3Parser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRIREF(self):
            return self.getToken(n3Parser.IRIREF, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_base

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase" ):
                listener.enterBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase" ):
                listener.exitBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBase" ):
                return visitor.visitBase(self)
            else:
                return visitor.visitChildren(self)




    def base(self):

        localctx = n3Parser.BaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_base)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(n3Parser.T__2)
            self.state = 95
            self.match(n3Parser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriplesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subject(self):
            return self.getTypedRuleContext(n3Parser.SubjectContext,0)


        def predicateObjectList(self):
            return self.getTypedRuleContext(n3Parser.PredicateObjectListContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_triples

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTriples" ):
                listener.enterTriples(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTriples" ):
                listener.exitTriples(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTriples" ):
                return visitor.visitTriples(self)
            else:
                return visitor.visitChildren(self)




    def triples(self):

        localctx = n3Parser.TriplesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_triples)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.subject()
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 30802416319936) != 0):
                self.state = 98
                self.predicateObjectList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateObjectListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verb(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.VerbContext)
            else:
                return self.getTypedRuleContext(n3Parser.VerbContext,i)


        def objectList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.ObjectListContext)
            else:
                return self.getTypedRuleContext(n3Parser.ObjectListContext,i)


        def getRuleIndex(self):
            return n3Parser.RULE_predicateObjectList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateObjectList" ):
                listener.enterPredicateObjectList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateObjectList" ):
                listener.exitPredicateObjectList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateObjectList" ):
                return visitor.visitPredicateObjectList(self)
            else:
                return visitor.visitChildren(self)




    def predicateObjectList(self):

        localctx = n3Parser.PredicateObjectListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_predicateObjectList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.verb()
            self.state = 102
            self.objectList()
            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 103
                self.match(n3Parser.T__3)
                self.state = 107
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 30802416319936) != 0):
                    self.state = 104
                    self.verb()
                    self.state = 105
                    self.objectList()


                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def object_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.ObjectContext)
            else:
                return self.getTypedRuleContext(n3Parser.ObjectContext,i)


        def getRuleIndex(self):
            return n3Parser.RULE_objectList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectList" ):
                listener.enterObjectList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectList" ):
                listener.exitObjectList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectList" ):
                return visitor.visitObjectList(self)
            else:
                return visitor.visitChildren(self)




    def objectList(self):

        localctx = n3Parser.ObjectListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_objectList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.object_()
            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 115
                self.match(n3Parser.T__4)
                self.state = 116
                self.object_()
                self.state = 121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(n3Parser.PredicateContext,0)


        def expression(self):
            return self.getTypedRuleContext(n3Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_verb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerb" ):
                listener.enterVerb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerb" ):
                listener.exitVerb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerb" ):
                return visitor.visitVerb(self)
            else:
                return visitor.visitChildren(self)




    def verb(self):

        localctx = n3Parser.VerbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_verb)
        try:
            self.state = 133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13, 16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 122
                self.predicate()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 2)
                self.state = 123
                self.match(n3Parser.T__5)
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 3)
                self.state = 124
                self.match(n3Parser.T__6)
                self.state = 125
                self.expression()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 4)
                self.state = 126
                self.match(n3Parser.T__7)
                self.state = 127
                self.expression()
                self.state = 128
                self.match(n3Parser.T__8)
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 5)
                self.state = 130
                self.match(n3Parser.T__9)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 6)
                self.state = 131
                self.match(n3Parser.T__10)
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 7)
                self.state = 132
                self.match(n3Parser.T__11)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(n3Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_subject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubject" ):
                listener.enterSubject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubject" ):
                listener.exitSubject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubject" ):
                return visitor.visitSubject(self)
            else:
                return visitor.visitChildren(self)




    def subject(self):

        localctx = n3Parser.SubjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_subject)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(n3Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = n3Parser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                self.state = 137
                self.expression()
                pass
            elif token in [13]:
                self.state = 138
                self.match(n3Parser.T__12)
                self.state = 139
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(n3Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObject" ):
                listener.enterObject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObject" ):
                listener.exitObject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObject" ):
                return visitor.visitObject(self)
            else:
                return visitor.visitChildren(self)




    def object_(self):

        localctx = n3Parser.ObjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_object)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path(self):
            return self.getTypedRuleContext(n3Parser.PathContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = n3Parser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.path()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pathItem(self):
            return self.getTypedRuleContext(n3Parser.PathItemContext,0)


        def path(self):
            return self.getTypedRuleContext(n3Parser.PathContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_path

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPath" ):
                listener.enterPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPath" ):
                listener.exitPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPath" ):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)




    def path(self):

        localctx = n3Parser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_path)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.pathItem()
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                self.state = 147
                self.match(n3Parser.T__13)
                self.state = 148
                self.path()
                pass
            elif token in [15]:
                self.state = 149
                self.match(n3Parser.T__14)
                self.state = 150
                self.path()
                pass
            elif token in [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PathItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(n3Parser.IriContext,0)


        def blankNode(self):
            return self.getTypedRuleContext(n3Parser.BlankNodeContext,0)


        def quickVar(self):
            return self.getTypedRuleContext(n3Parser.QuickVarContext,0)


        def collection(self):
            return self.getTypedRuleContext(n3Parser.CollectionContext,0)


        def blankNodePropertyList(self):
            return self.getTypedRuleContext(n3Parser.BlankNodePropertyListContext,0)


        def iriPropertyList(self):
            return self.getTypedRuleContext(n3Parser.IriPropertyListContext,0)


        def literal(self):
            return self.getTypedRuleContext(n3Parser.LiteralContext,0)


        def formula(self):
            return self.getTypedRuleContext(n3Parser.FormulaContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_pathItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPathItem" ):
                listener.enterPathItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPathItem" ):
                listener.exitPathItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPathItem" ):
                return visitor.visitPathItem(self)
            else:
                return visitor.visitChildren(self)




    def pathItem(self):

        localctx = n3Parser.PathItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_pathItem)
        try:
            self.state = 161
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26, 27, 28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 153
                self.iri()
                pass
            elif token in [29, 43]:
                self.enterOuterAlt(localctx, 2)
                self.state = 154
                self.blankNode()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 3)
                self.state = 155
                self.quickVar()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 4)
                self.state = 156
                self.collection()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 5)
                self.state = 157
                self.blankNodePropertyList()
                pass
            elif token in [42]:
                self.enterOuterAlt(localctx, 6)
                self.state = 158
                self.iriPropertyList()
                pass
            elif token in [24, 25, 31, 32, 33]:
                self.enterOuterAlt(localctx, 7)
                self.state = 159
                self.literal()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 8)
                self.state = 160
                self.formula()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rdfLiteral(self):
            return self.getTypedRuleContext(n3Parser.RdfLiteralContext,0)


        def numericLiteral(self):
            return self.getTypedRuleContext(n3Parser.NumericLiteralContext,0)


        def BooleanLiteral(self):
            return self.getToken(n3Parser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = n3Parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_literal)
        try:
            self.state = 166
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25]:
                self.enterOuterAlt(localctx, 1)
                self.state = 163
                self.rdfLiteral()
                pass
            elif token in [31, 32, 33]:
                self.enterOuterAlt(localctx, 2)
                self.state = 164
                self.numericLiteral()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 3)
                self.state = 165
                self.match(n3Parser.BooleanLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlankNodePropertyListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicateObjectList(self):
            return self.getTypedRuleContext(n3Parser.PredicateObjectListContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_blankNodePropertyList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlankNodePropertyList" ):
                listener.enterBlankNodePropertyList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlankNodePropertyList" ):
                listener.exitBlankNodePropertyList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlankNodePropertyList" ):
                return visitor.visitBlankNodePropertyList(self)
            else:
                return visitor.visitChildren(self)




    def blankNodePropertyList(self):

        localctx = n3Parser.BlankNodePropertyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_blankNodePropertyList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(n3Parser.T__15)
            self.state = 169
            self.predicateObjectList()
            self.state = 170
            self.match(n3Parser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IriPropertyListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IPLSTART(self):
            return self.getToken(n3Parser.IPLSTART, 0)

        def iri(self):
            return self.getTypedRuleContext(n3Parser.IriContext,0)


        def predicateObjectList(self):
            return self.getTypedRuleContext(n3Parser.PredicateObjectListContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_iriPropertyList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIriPropertyList" ):
                listener.enterIriPropertyList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIriPropertyList" ):
                listener.exitIriPropertyList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIriPropertyList" ):
                return visitor.visitIriPropertyList(self)
            else:
                return visitor.visitChildren(self)




    def iriPropertyList(self):

        localctx = n3Parser.IriPropertyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_iriPropertyList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(n3Parser.IPLSTART)
            self.state = 173
            self.iri()
            self.state = 174
            self.predicateObjectList()
            self.state = 175
            self.match(n3Parser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def object_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(n3Parser.ObjectContext)
            else:
                return self.getTypedRuleContext(n3Parser.ObjectContext,i)


        def getRuleIndex(self):
            return n3Parser.RULE_collection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollection" ):
                listener.enterCollection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollection" ):
                listener.exitCollection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollection" ):
                return visitor.visitCollection(self)
            else:
                return visitor.visitChildren(self)




    def collection(self):

        localctx = n3Parser.CollectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_collection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(n3Parser.T__17)
            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 30802416304128) != 0):
                self.state = 178
                self.object_()
                self.state = 183
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 184
            self.match(n3Parser.T__18)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formulaContent(self):
            return self.getTypedRuleContext(n3Parser.FormulaContentContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula" ):
                listener.enterFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula" ):
                listener.exitFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula" ):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)




    def formula(self):

        localctx = n3Parser.FormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_formula)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(n3Parser.T__19)
            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 875227346436108) != 0):
                self.state = 187
                self.formulaContent()


            self.state = 190
            self.match(n3Parser.T__20)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormulaContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def n3Statement(self):
            return self.getTypedRuleContext(n3Parser.N3StatementContext,0)


        def formulaContent(self):
            return self.getTypedRuleContext(n3Parser.FormulaContentContext,0)


        def sparqlDirective(self):
            return self.getTypedRuleContext(n3Parser.SparqlDirectiveContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_formulaContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormulaContent" ):
                listener.enterFormulaContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormulaContent" ):
                listener.exitFormulaContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormulaContent" ):
                return visitor.visitFormulaContent(self)
            else:
                return visitor.visitChildren(self)




    def formulaContent(self):

        localctx = n3Parser.FormulaContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_formulaContent)
        self._la = 0 # Token type
        try:
            self.state = 203
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2, 3, 16, 18, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 192
                self.n3Statement()
                self.state = 197
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1:
                    self.state = 193
                    self.match(n3Parser.T__0)
                    self.state = 195
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 875227346436108) != 0):
                        self.state = 194
                        self.formulaContent()




                pass
            elif token in [48, 49]:
                self.enterOuterAlt(localctx, 2)
                self.state = 199
                self.sparqlDirective()
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 875227346436108) != 0):
                    self.state = 200
                    self.formulaContent()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(n3Parser.INTEGER, 0)

        def DECIMAL(self):
            return self.getToken(n3Parser.DECIMAL, 0)

        def DOUBLE(self):
            return self.getToken(n3Parser.DOUBLE, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericLiteral" ):
                return visitor.visitNumericLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numericLiteral(self):

        localctx = n3Parser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_numericLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 15032385536) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def String(self):
            return self.getToken(n3Parser.String, 0)

        def LANGTAG(self):
            return self.getToken(n3Parser.LANGTAG, 0)

        def iri(self):
            return self.getTypedRuleContext(n3Parser.IriContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_rdfLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfLiteral" ):
                listener.enterRdfLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfLiteral" ):
                listener.exitRdfLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRdfLiteral" ):
                return visitor.visitRdfLiteral(self)
            else:
                return visitor.visitChildren(self)




    def rdfLiteral(self):

        localctx = n3Parser.RdfLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_rdfLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self.match(n3Parser.String)
            self.state = 211
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [30]:
                self.state = 208
                self.match(n3Parser.LANGTAG)
                pass
            elif token in [22]:
                self.state = 209
                self.match(n3Parser.T__21)
                self.state = 210
                self.iri()
                pass
            elif token in [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 31, 32, 33, 42, 43, 44]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IriContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRIREF(self):
            return self.getToken(n3Parser.IRIREF, 0)

        def prefixedName(self):
            return self.getTypedRuleContext(n3Parser.PrefixedNameContext,0)


        def getRuleIndex(self):
            return n3Parser.RULE_iri

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIri" ):
                listener.enterIri(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIri" ):
                listener.exitIri(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIri" ):
                return visitor.visitIri(self)
            else:
                return visitor.visitChildren(self)




    def iri(self):

        localctx = n3Parser.IriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_iri)
        try:
            self.state = 215
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.enterOuterAlt(localctx, 1)
                self.state = 213
                self.match(n3Parser.IRIREF)
                pass
            elif token in [27, 28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 214
                self.prefixedName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixedNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PNAME_NS(self):
            return self.getToken(n3Parser.PNAME_NS, 0)

        def PNAME_LN(self):
            return self.getToken(n3Parser.PNAME_LN, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_prefixedName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixedName" ):
                listener.enterPrefixedName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixedName" ):
                listener.exitPrefixedName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixedName" ):
                return visitor.visitPrefixedName(self)
            else:
                return visitor.visitChildren(self)




    def prefixedName(self):

        localctx = n3Parser.PrefixedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_prefixedName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            _la = self._input.LA(1)
            if not(_la==27 or _la==28):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlankNodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLANK_NODE_LABEL(self):
            return self.getToken(n3Parser.BLANK_NODE_LABEL, 0)

        def ANON(self):
            return self.getToken(n3Parser.ANON, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_blankNode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlankNode" ):
                listener.enterBlankNode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlankNode" ):
                listener.exitBlankNode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlankNode" ):
                return visitor.visitBlankNode(self)
            else:
                return visitor.visitChildren(self)




    def blankNode(self):

        localctx = n3Parser.BlankNodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_blankNode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            _la = self._input.LA(1)
            if not(_la==29 or _la==43):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuickVarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QuickVarName(self):
            return self.getToken(n3Parser.QuickVarName, 0)

        def getRuleIndex(self):
            return n3Parser.RULE_quickVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuickVar" ):
                listener.enterQuickVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuickVar" ):
                listener.exitQuickVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuickVar" ):
                return visitor.visitQuickVar(self)
            else:
                return visitor.visitChildren(self)




    def quickVar(self):

        localctx = n3Parser.QuickVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_quickVar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.match(n3Parser.QuickVarName)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





